% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\encoding{UTF-8}
\name{pbbo}
\alias{pbbo}
\title{\code{pbbo}: prior by Bayesian optimisation}
\usage{
pbbo(
  model_name = "default",
  target_lcdf,
  target_sampler,
  prior_predictive_sampler,
  param_set,
  covariate_values = NULL,
  discrepancy = "log_cvm",
  initial_points_to_eval = NULL,
  n_internal_prior_draws = 250,
  importance_method = "uniform",
  importance_lower = NULL,
  importance_upper = NULL,
  n_internal_importance_draws = 100,
  bayes_opt_iters = 100,
  bayes_opt_print = FALSE,
  ...
)
}
\arguments{
\item{model_name}{String: name of the model/optimisation function}

\item{target_lcdf}{Function: Vectorised target log-CDF. Takes one argument, a
vector of points at which we wish to evaluate the log-CDF. This function
must accept \code{\link[Rmpfr]{mpfr}} points. This requirement handled by
calling \code{as.numeric} on the vector of points, but performance is
improved by using high precision versions of functions compatible with
\code{\link[Rmpfr]{mpfr}} points. See \code{\link[Rmpfr]{mpfr-class}}
for a range of such functions.}

\item{target_sampler}{Function: Generates samples from the target
distribution. Takes one argument \code{n}, the desired number of samples.}

\item{prior_predictive_sampler}{Function: Generates samples from the prior
predictive distribution. Takes two arguments: \code{n}, the desired number
of samples; and \code{lambda}, a named vector whose names correspond to the
hyperparameters of interest (and defined by \code{param_set}).}

\item{param_set}{A \code{\link[ParamHelpers]{makeParamSet}}: Parameter set
corresponding to the hyperparameters of interest. Best understood by
inspecting the example. For an example with vectors of parameters, we could
take

\preformatted{param_set <- makeParamSet(
    makeNumericVectorParam(id = 'mu', len = 2, lower = -50, upper = 50),
    makeNumericParam(id = 'sigma', lower = 0, upper = 20)
)}

the elements of which would be accessible inside
\code{prior_predictive_sampler} as \code{c(lambda['mu1'], lambda['mu2'],
  lambda['sigma'])}.}

\item{covariate_values}{An optional vector or matrix/data.frame of covariate
values: \bold{including covariate values changes the signautres required
for} \code{target_lcdf}, \code{target_sampler}, \bold{and}
\code{prior_predictive_sampler}. Each of these function must take an
additional third argument, perhaps called \code{cov}, that ditates the
behaviour of the function at a specific covariate value, i.e. value in the
covariate vector or row in the covariate matrix.}

\item{discrepancy}{String (or Function): One of either \code{'log_cvm'} or
\code{'log_ad'} for Cramér–von Mises (default) or Anderson–Darling distance
respectively. The latter is currenly unsupported as it is too numerically
difficult to compute accurately. Alternatively, one can supply a function
with thesignature \code{function(cdf_1, cdf_2, points, weights)}, where the
first two arguments are (E)CDF functions, \code{points} is a vector of
evaluation points, and \code{weights} is the corresponding vector of
importance weights.}

\item{initial_points_to_eval}{\code{data.frame}: A data.frame of points at
which one might wish to evaluate the discrepancy function at initially. The
colums of this data.farme must match the names as described by
\code{param_set}, and include a column called \code{y}, which may be full
of \code{NA}s if the discrepancy has not been evaluated at the points.
Defaults to \code{NULL}.}

\item{n_internal_prior_draws}{Numeric: Number of draws to generate from the
prior predictive distribution for the given value of \code{lambda} in each
of the optimisation iterations. More draws result in better estimates of
the ECDF.}

\item{importance_method}{String: Defaults to \code{'uniform'}. Perhaps in the
future this will allow one to adjust the type of importance sampling use to
compute the discrepancy function.}

\item{importance_lower}{Numeric: Defaults to \code{NULL}. The default
'uniform' Importance sampling method sets the lower bound of the uniform
importance distribution to be \code{min(sample_from_target,
  sample_from_current_prior_predictive)}. If you wish to set this lower bound
manually, perhaps if the draws from the  prior predictive distribution have
a compact support, then set \code{importance_lower} to a specific value}

\item{importance_upper}{Numeric: Defaults to \code{NULL}. Corresponding
upper bound to \code{importance_lower}.}

\item{n_internal_importance_draws}{Numeric: Number of draws to generate from
the importance distribution, and subsequently used to evalute the
discrepancy intergral.}

\item{bayes_opt_iters}{Numeric: Number of iterations of Bayesian optimisation
to use. Passed to \code{\link[mlrMBO]{setMBOControlTermination}} as
\code{iters}.}

\item{bayes_opt_print}{Boolean: if \code{TRUE}, print the progress/status
from \code{\link[mlrMBO]{mbo}}. Defaults to \code{FALSE}.}

\item{...}{Currently unused.}
}
\value{
An \code{\link[mlrMBO]{MBOSingleObjResult}}.
}
\description{
\code{pbbo}: prior by Bayesian optimisation
}
\examples{
\dontrun{
library(pbbo)
library(mlrMBO)

target_lcdf <- function(x) {
  pnorm(x, mean = 2, sd = 0.5, log.p = TRUE)
}

target_sampler <- function(n) {
  rnorm(n = n, mean = 2, sd = 0.5)
}

prior_predictive_sampler <- function(n, lambda) {
  rnorm(n = n, mean = lambda['mu'], sd = lambda['sigma'])
}

param_set <- makeParamSet(
  makeNumericParam(id = 'mu', default = 0.2, lower = -50, upper = 50),
  makeNumericParam(id = 'sigma', lower = 0, upper = 20, default = 0.2)
)

pbbo(
  model_name = 'test_normal',
  target_lcdf = target_lcdf,
  target_sampler = target_sampler,
  prior_predictive_sampler = prior_predictive_sampler,
  discrepancy = 'cvm',
  param_set = param_set,
  n_internal_prior_draws = 750,
  n_internal_importance_draws = 200,
  bayes_opt_iters = 50,
  bayes_opt_print = FALSE
)}
}
